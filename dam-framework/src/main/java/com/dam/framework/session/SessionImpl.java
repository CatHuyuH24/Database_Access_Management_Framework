package com.dam.framework.session;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.dam.framework.annotations.GenerationType;
import com.dam.framework.dialect.Dialect;
import com.dam.framework.exception.DAMException;
import com.dam.framework.mapping.ColumnMetadata;
import com.dam.framework.mapping.EntityKey;
import com.dam.framework.mapping.EntityMetadata;
import com.dam.framework.mapping.IdGenerator;
import com.dam.framework.mapping.IdGeneratorFactory;
import com.dam.framework.query.Query;
import com.dam.framework.query.QueryImpl;
import com.dam.framework.sql.SQLGenerator;
import com.dam.framework.transaction.Transaction;
import com.dam.framework.util.ReflectionUtils;
import com.dam.framework.util.TypeMapper;

class SessionImpl implements Session {

    private final InternalSessionFactory factory;
    private final Map<EntityKey, Object> attachedEntities; // L1 cache - stores actual entity instances
    private final Connection connection;
    private final Map<EntityKey, Map<String, Object>> originalSnapshots;
    private final SQLGenerator sqlGenerator;
    private final Dialect dialect;
    private final boolean showSQL;
    private static final Logger logger = LoggerFactory.getLogger(SessionImpl.class);

    public SessionImpl(InternalSessionFactory factory,
            Connection connection, SQLGenerator sqlGenerator, Dialect dialect, boolean showSQL) {
        this.factory = factory;
        this.attachedEntities = new HashMap<>(); // Initialize L1 cache as empty
        this.connection = connection;
        originalSnapshots = new HashMap<>();
        this.sqlGenerator = sqlGenerator;
        this.dialect = dialect;
        this.showSQL = showSQL;
    }

    @Override
    public void close() throws Exception {
        // clear L1 cache (session-specific data)
        attachedEntities.clear();
        originalSnapshots.clear();

        // notify the internal factory to release connection and remove from tracking
        factory.sessionClosed(this);
    }

    @Override
    public <T> void persist(T entity) {
        // 1. Get metadata
        EntityMetadata metadata = factory.getMetadata(entity.getClass());
        if (metadata == null) {
            throw new DAMException("Entity class not registered: " + entity.getClass().getName());
        }

        // 2. Get ID column and current value
        ColumnMetadata idColumn = metadata.getIdColumn();
        Object id = ReflectionUtils.getFieldValue(entity, idColumn.field());

        // 3. Check L1 cache if ID exists
        if (id != null) {
            EntityKey key = new EntityKey(entity.getClass(), id);
            if (attachedEntities.containsKey(key)) {
                return; // Already persisted
            }
        }

        // 4. Handle ID generation if needed
        if (id == null && idColumn.isAutoGenerated()) {
            GenerationType strategy = idColumn.getGenerationStrategy();
            IdGenerator generator = IdGeneratorFactory.createGenerator(strategy);

            // For pre-insert generators (UUID, SEQUENCE), generate ID now
            if (!generator.isPostInsertGenerator()) {
                id = generator.generate(connection, dialect, metadata);
                ReflectionUtils.setFieldValue(entity, idColumn.field(), id);
            }
        }

        // 5. Generate INSERT SQL
        String sql = sqlGenerator.generateInsert(metadata);

        // 6. Execute SQL
        try (PreparedStatement stmt = connection.prepareStatement(sql,
                Statement.RETURN_GENERATED_KEYS)) {

            int paramIndex = 1;
            for (ColumnMetadata col : metadata.getColumns()) {
                // Skip auto-generated ID columns that use post-insert generation (IDENTITY)
                if (col.equals(idColumn) && col.isAutoGenerated() &&
                        col.getGenerationStrategy() == GenerationType.IDENTITY) {
                    continue; // Database will generate this value
                }

                Object value = ReflectionUtils.getFieldValue(entity, col.field());
                dialect.setParameter(stmt, paramIndex++, value, col.javaType());
            }

            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected == 0) {
                throw new DAMException("INSERT failed, no rows affected");
            }

            // 7. Handle post-insert ID generation (IDENTITY strategy)
            if (id == null && idColumn.isAutoGenerated() &&
                    idColumn.getGenerationStrategy() == GenerationType.IDENTITY) {

                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        // Get generated ID from database
                        Object generatedId = generatedKeys.getObject(1);

                        // Convert to correct type
                        Class<?> idType = idColumn.javaType();
                        if (idType == Long.class || idType == long.class) {
                            id = generatedId instanceof Long
                                    ? generatedId
                                    : ((Number) generatedId).longValue();
                        } else if (idType == Integer.class || idType == int.class) {
                            id = generatedId instanceof Integer
                                    ? generatedId
                                    : ((Number) generatedId).intValue();
                        } else {
                            id = generatedId;
                        }

                        // Set ID back to entity
                        ReflectionUtils.setFieldValue(entity, idColumn.field(), id);
                    } else {
                        throw new DAMException(
                                "INSERT succeeded but no generated key returned. " +
                                        "Check @GeneratedValue configuration.");
                    }
                }
            }

            // 8. Add to L1 cache (now ID is guaranteed to be non-null)
            EntityKey key = new EntityKey(entity.getClass(), id);
            attachedEntities.put(key, entity);

            // 9. Create snapshot
            originalSnapshots.put(key, createSnapshot(entity, metadata));

        } catch (SQLException e) {
            throw new DAMException(
                    "Failed to persist entity: " + entity.getClass().getSimpleName(),
                    e);
        }
    }

    private <T> T mapResultSetToEntity(ResultSet rs, EntityMetadata entityMetadata) {
        @SuppressWarnings("unchecked")
        T entity = ReflectionUtils.newInstance((Class<T>) entityMetadata.getEntityClass());

        for (ColumnMetadata column : entityMetadata.getColumns()) {
            Object value;
            try {
                // Use TypeMapper for type-safe conversion
                value = TypeMapper.getResultSetValue(rs, column.columnName(), column.javaType());
            } catch (SQLException e) {
                throw new DAMException("Failed to map column: " + column.columnName(), e);
            }
            ReflectionUtils.setFieldValue(entity, column.field(), value);
        }

        return entity;
    }

    @Override
    public <T> T find(Class<T> entityClass, Object id) {
        // 1. Check L1 cache
        EntityKey key = new EntityKey(entityClass, id);
        Object cached = attachedEntities.get(key);
        if (cached != null) {
            return entityClass.cast(cached);
        }

        // 2. Query database
        EntityMetadata metadata = factory.getMetadata(entityClass);

        // Use SQLGenerator for consistency
        String sql = sqlGenerator.generateSelectById(metadata);

        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            // Use dialect for type safety
            dialect.setParameter(stmt, 1, id, metadata.getIdColumn().javaType());

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    T entity = mapResultSetToEntity(rs, metadata);

                    // 3. Add to L1 cache FIRST
                    attachedEntities.put(key, entity);

                    // 4. Create snapshot
                    originalSnapshots.put(key, createSnapshot(entity, metadata));

                    return entity;
                }
            }
        } catch (SQLException e) {
            throw new DAMException("Failed to find entity: " + entityClass.getSimpleName(), e);
        }

        return null;
    }

    @Override
    public <T> T merge(T entity) {
        // 1. Get metadata and ID
        EntityMetadata metadata = factory.getMetadata(entity.getClass());
        if (metadata == null) {
            throw new DAMException("Entity class not registered: " + entity.getClass().getName());
        }

        ColumnMetadata idColumn = metadata.getIdColumn();
        Object id = ReflectionUtils.getFieldValue(entity, idColumn.field());

        if (id == null) {
            throw new DAMException("Cannot merge entity with null ID. Use persist() for new entities.");
        }

        // 2. Check if entity exists in database
        @SuppressWarnings("unchecked")
        T existing = find((Class<T>) entity.getClass(), id);

        if (existing == null) {
            // Entity doesn't exist - do INSERT instead
            persist(entity);
            return entity;
        }

        // 3. Entity exists - do UPDATE
        String sql = sqlGenerator.generateUpdate(metadata);
        if (showSQL) {
            logger.debug("Session Merging\nSQL: {}", sql);
        }
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            int paramIndex = 1;

            // Set all column values (except ID)
            for (ColumnMetadata col : metadata.getColumns()) {
                if (!col.equals(idColumn)) {
                    Object value = ReflectionUtils.getFieldValue(entity, col.field());
                    dialect.setParameter(stmt, paramIndex++, value, col.javaType());
                }
            }

            // Set ID for WHERE clause
            dialect.setParameter(stmt, paramIndex, id, idColumn.javaType());

            // Execute UPDATE
            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected == 0) {
                throw new DAMException("UPDATE failed, entity might have been deleted");
            }

            // Update L1 cache
            EntityKey key = new EntityKey(entity.getClass(), id);
            attachedEntities.put(key, entity);
            originalSnapshots.put(key, createSnapshot(entity, metadata));

            return entity;

        } catch (SQLException e) {
            throw new DAMException("Failed to merge entity: " + entity.getClass().getSimpleName(), e);
        }
    }

    @Override
    public void remove(Object entity) {
        // 1. Get metadata and ID
        EntityMetadata metadata = factory.getMetadata(entity.getClass());
        if (metadata == null) {
            throw new DAMException("Entity class not registered: " + entity.getClass().getName());
        }

        ColumnMetadata idColumn = metadata.getIdColumn();
        Object id = ReflectionUtils.getFieldValue(entity, idColumn.field());

        if (id == null) {
            throw new DAMException("Cannot remove entity with null ID");
        }

        // 2. Generate DELETE SQL
        String sql = sqlGenerator.generateDelete(metadata);
        if (showSQL) {
            logger.debug("Session Removing\nSQL: {}", sql);

        }
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            // Set ID parameter
            dialect.setParameter(stmt, 1, id, idColumn.javaType());

            // Execute DELETE
            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected == 0) {
                // Entity might not exist in DB, but that's ok for remove()
                // (idempotent operation)
            }

            // Remove from L1 cache
            EntityKey key = new EntityKey(entity.getClass(), id);
            attachedEntities.remove(key);
            originalSnapshots.remove(key);

        } catch (SQLException e) {
            throw new DAMException("Failed to remove entity: " + entity.getClass().getSimpleName(), e);
        }
    }

    @Override
    public <T> Query<T> createQuery(Class<T> resultClass) {
        EntityMetadata metadata = factory.getMetadata(resultClass);
        return new QueryImpl<>(resultClass, connection, dialect, metadata); // PASS metadata!
    }

    @Override
    public Transaction beginTransaction() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'beginTransaction'");
    }

    private List<ColumnMetadata> getChangedColumns(Map.Entry<EntityKey, Object> currentAttachedObject) {
        List<ColumnMetadata> changedColumns = new ArrayList<>();
        Object entity = currentAttachedObject.getValue();
        EntityMetadata metadata = factory.getMetadata(entity.getClass());

        EntityKey key = currentAttachedObject.getKey();
        Map<String, Object> originalSnapshot = originalSnapshots.get(key);

        if (originalSnapshot == null) {
            // No snapshot - entity was never persisted/merged in this session
            // Return all columns as changed (shouldn't happen in normal flow)
            return new ArrayList<>(metadata.getColumns());
        }

        for (ColumnMetadata col : metadata.getColumns()) {
            Object currentValue = ReflectionUtils.getFieldValue(entity, col.field());
            Object originalValue = originalSnapshot.get(col.columnName());

            // Compare values
            if (!Objects.equals(currentValue, originalValue)) {
                changedColumns.add(col);
            }
        }

        return changedColumns;
    }

    @Override
    public void flush() {
        // Iterate through all attached entities and check for changes
        for (Map.Entry<EntityKey, Object> entry : attachedEntities.entrySet()) {
            EntityKey key = entry.getKey();
            Object entity = entry.getValue();

            // Get changed columns using existing helper
            List<ColumnMetadata> changedColumns = getChangedColumns(entry);

            if (!changedColumns.isEmpty()) {
                // Entity has changes - perform UPDATE
                EntityMetadata metadata = factory.getMetadata(entity.getClass());
                ColumnMetadata idColumn = metadata.getIdColumn();
                Object id = ReflectionUtils.getFieldValue(entity, idColumn.field());

                String sql = sqlGenerator.generatePartialUpdate(metadata, changedColumns);
                if (showSQL) {
                    logger.debug("Session Flushing\nSQL: {}", sql);

                }
                try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                    int paramIndex = 1;

                    // Set all column values (except ID)
                    for (ColumnMetadata col : metadata.getColumns()) {
                        if (!col.equals(idColumn)) {
                            Object value = ReflectionUtils.getFieldValue(entity, col.field());
                            dialect.setParameter(stmt, paramIndex++, value, col.javaType());
                        }
                    }

                    // Set ID for WHERE clause
                    dialect.setParameter(stmt, paramIndex, id, idColumn.javaType());

                    // Execute UPDATE
                    int rowsAffected = stmt.executeUpdate();
                    if (rowsAffected == 0) {
                        throw new DAMException(
                                "UPDATE failed during flush, entity might have been deleted: " +
                                        entity.getClass().getSimpleName() + " with ID " + id);
                    }

                    // Update snapshot after successful flush
                    originalSnapshots.put(key, createSnapshot(entity, metadata));

                } catch (SQLException e) {
                    throw new DAMException("Failed to flush changes for: " +
                            entity.getClass().getSimpleName(), e);
                }
            }
        }
    }

    private Map<String, Object> createSnapshot(Object entity, EntityMetadata metadata) {
        Map<String, Object> snapshot = new HashMap<>();
        for (ColumnMetadata col : metadata.getColumns()) {
            Object value = ReflectionUtils.getFieldValue(entity, col.field());
            // Clone value to prevent reference issues
            snapshot.put(col.columnName(), value);
        }
        return snapshot;
    }

};
