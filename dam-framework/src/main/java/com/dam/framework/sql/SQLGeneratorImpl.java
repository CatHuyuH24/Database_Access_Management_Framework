package com.dam.framework.sql;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import com.dam.framework.annotations.GenerationType;
import com.dam.framework.exception.DAMException;
import com.dam.framework.mapping.ColumnMetadata;
import com.dam.framework.mapping.EntityMetadata;

public final class SQLGeneratorImpl implements SQLGenerator {

    @Override
    public String generateInsert(EntityMetadata metadata) {
        ColumnMetadata idColumn = metadata.getIdColumn();

        // Get columns excluding auto-generated IDENTITY columns
        List<ColumnMetadata> columns = metadata.getColumns().stream()
                .filter(col -> {
                    // Include column if:
                    // 1. It's not the ID column, OR
                    // 2. It's the ID but not auto-generated with IDENTITY strategy
                    if (!col.equals(idColumn)) {
                        return true;
                    }

                    // Exclude ID only if it uses IDENTITY generation (database generates it)
                    // Include ID if it uses UUID, SEQUENCE, or NONE (application sets it)
                    return !col.isAutoGenerated() ||
                            col.getGenerationStrategy() != GenerationType.IDENTITY;
                })
                .collect(Collectors.toList());

        String tableName = getFullTableName(metadata);

        StringBuilder columnNames = new StringBuilder(columns.stream()
                .map(ColumnMetadata::columnName)
                .collect(Collectors.joining(", ")));

        StringBuilder placeholders = new StringBuilder(
                String.join(", ", Collections.nCopies(columns.size(), "?")));

        if (metadata.getDiscriminatorColumn() != null) {
            columnNames.append(", ").append(metadata.getDiscriminatorColumn());
            placeholders.append(", '").append(metadata.getDiscriminatorValue()).append("'");
        }

        return String.format("INSERT INTO %s (%s) VALUES (%s)",
                tableName, columnNames, placeholders);
    }

    @Override
    public String generateSelect(EntityMetadata metadata) {
        // SELECT * FROM schema.table
        String sql = String.format("SELECT * FROM %s", getFullTableName(metadata));
        return applyDiscriminatorFilter(metadata, sql, false);
    }

    @Override
    public String generateSelectById(EntityMetadata metadata) {
        // SELECT * FROM schema.table WHERE id_column = ?
        String sql = String.format("SELECT * FROM %s WHERE %s = ?",
                getFullTableName(metadata),
                metadata.getIdColumn().columnName());
        return applyDiscriminatorFilter(metadata, sql, true);
    }

    @Override
    public String generateUpdate(EntityMetadata metadata) {
        // UPDATE schema.table SET col1 = ?, col2 = ? WHERE id_column = ?
        String tableName = getFullTableName(metadata);

        String setClause = metadata.getColumns().stream()
                .filter(col -> !col.columnName().equalsIgnoreCase(metadata.getIdColumn().columnName()))
                .map(col -> col.columnName() + " = ?")
                .collect(Collectors.joining(", "));

        return String.format("UPDATE %s SET %s WHERE %s = ?",
                tableName,
                setClause,
                metadata.getIdColumn().columnName());
    }

    @Override
    public String generateDelete(EntityMetadata metadata) {
        // DELETE FROM schema.table WHERE id_column = ?
        return String.format("DELETE FROM %s WHERE %s = ?",
                getFullTableName(metadata),
                metadata.getIdColumn().columnName());
    }

    private String getFullTableName(EntityMetadata metadata) {
        String schema = metadata.getSchema();
        String table = metadata.getTableName();
        if (schema != null && !schema.isBlank() && !"public".equalsIgnoreCase(schema)) {
            return schema + "." + table;
        }
        return table;
    }

    private String applyDiscriminatorFilter(EntityMetadata metadata, String sql, boolean hasExistingWhere) {
        if (metadata.getDiscriminatorColumn() == null) {
            return sql;
        }

        String prefix = hasExistingWhere ? " AND " : " WHERE ";
        return sql + prefix + metadata.getDiscriminatorColumn() + " = '" + metadata.getDiscriminatorValue() + "'";
    }

    @Override
    public String generatePartialUpdate(EntityMetadata metadata, List<ColumnMetadata> changedColumns) {
        if (changedColumns == null || changedColumns.isEmpty()) {
            throw new DAMException("No columns to update");
        }

        // Filter out ID column from changed columns - ID should never be updated
        ColumnMetadata idColumn = metadata.getIdColumn();
        List<ColumnMetadata> updatableColumns = changedColumns.stream()
                .filter(col -> !col.columnName().equalsIgnoreCase(idColumn.columnName()))
                .collect(Collectors.toList());

        // If only the ID was in changedColumns, nothing to update
        if (updatableColumns.isEmpty()) {
            throw new DAMException("No updatable columns found. ID column cannot be updated.");
        }

        String tableName = getFullTableName(metadata);
        String setClause = updatableColumns.stream()
                .map(col -> col.columnName() + " = ?")
                .collect(Collectors.joining(", "));

        return String.format("UPDATE %s SET %s WHERE %s = ?",
                tableName, setClause, metadata.getIdColumn().columnName());
    }
}